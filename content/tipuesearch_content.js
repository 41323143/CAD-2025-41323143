var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 電腦輔助設計與實習 \n github: https://github.com/41323143/CAD-2025-41323143 \n 群組網站: https://41323143.github.io/CAD-2025-41323143/content/index.html \n 課程評分: \n 學習心得報告 (60%)  - MS Teams 線上參與，6人一組每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 學習心得報告主題 : \n w3: 用什麼套件完成  5-bar Linkage Plotter  與  Openduck mini  零組件設計繪圖？  Solvespace ,  Siemens NX ,  Onshape  或其他？各有什麼優缺點？ ( plotter.7z ,  open_duck_mini.7z ) \n w7 ( 2a 採 Youtube 影片簡報 ):  5-bar Linkage Plotter  與  Openduck mini \xa0零組件設計繪製完成之後，如何切割零件? 為何要切割零件？ 如何利用  Webots  進行後續的控制系統設計與動態模擬 (Dynamic Simulation)？( plotter_project.7z ) \n w10:  Webots  是什麼？有什麼特點？ 如何進行場景模擬？ 如何用 Python 進行控制系統設計？ ( Tutorial ) \n w14:  Webots  的模型有沒有辦法用程式方法建立? 有沒有辦法直接從 CAD 套件中轉出  Webots  的場景模型？ \n w17: 如何實作一套  5-bar Linkage Plotter  與  Openduck mini ？( Disney Bipedal Robot ) \n w18: 課程總結 \n 個人與分組網站維護 (40%)  - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評', 'tags': '', 'url': 'About.html'}, {'title': 'w3', 'text': '用什麼套件完成\xa0 5-bar Linkage Plotter \xa0與\xa0 Openduck mini \xa0零組件設計繪圖？\xa0 Solvespace ,\xa0 Siemens NX ,\xa0 Onshape \xa0或其他？各有什麼優缺點？ ( plotter.7z ,\xa0 open_duck_mini.7z ) \n \n 我們這組選擇使用 Onshape 來進行繪製\xa0 5-bar Linkage Plotter \xa0 與 \xa0 Openduck mini \xa0 零組件設計繪圖 ，主要原因是它是一個雲端 CAD 平台，不需要安裝軟體即可透過網頁操作。Onshape 最大的優點是 即時協作，小組成員可以同時在線上編輯同一個檔案，彼此的修改會立即同步，避免了傳統 CAD 軟體需要反覆傳檔、合併的麻煩。這對於團隊合作特別有幫助，因為大家能在同一個工作環境中看到零組件的最新狀態，快速分工並組裝整體模型 \n SolveSpace 、 Siemens NX 、 Onshape 優缺點整理 \n \n \n \n \n 特性 \n \n \n SolveSpace \n \n \n Siemens NX \n \n \n Onshape \n \n \n \n \n 定位 \xa0 / \xa0 族群 \n \n \n 開源、免費，適合個人、教學、小型設計專案 \n \n \n 工業級 CAD/CAM/CAE，企業與大型產品開發 \n \n \n 雲端 SaaS CAD，適合團隊協作與中小型專案 \n \n \n \n \n 成本 \xa0 / \xa0 授權 \n \n \n 免費、開源 \n \n \n 高昂授權費 \n \n \n 訂閱制，有免費教育版 \n \n \n \n \n 安裝 \xa0 / \xa0 執行 \n \n \n 桌面應用，跨平台（Win / macOS / Linux） \n \n \n 桌面應用，需要高效能工作站 \n \n \n 免安裝，瀏覽器 / App 即可 \n \n \n \n \n 學習曲線 \n \n \n 中等，界面簡單但不直觀 \n \n \n 陡峭，功能龐雜、操作複雜 \n \n \n 較平緩，上手容易，界面現代 \n \n \n \n \n 核心功能 \n \n \n 參數建模、2D/3D 繪圖、簡單機構模擬 \n \n \n 參數建模、曲面建模、裝配、CAE、CAM、PLM 整合 \n \n \n 參數建模、裝配、工程圖、版本控制 \n \n \n \n \n 效能需求 \n \n \n 低，可在舊電腦運行 \n \n \n 高，需要專業硬體 \n \n \n 中等，主要依賴網路與伺服器 \n \n \n \n \n 優點 \n \n \n 免費、輕量、跨平台、快速原型 \n \n \n 功能最全、精度高、適合複雜產品開發 \n \n \n 雲端協作強、跨平台、易用、版本管理完善 \n \n \n \n \n 缺點 \n \n \n 功能有限、不穩定、界面不直觀 \n \n \n 成本高、學習曲線陡、操作繁瑣 \n \n \n 雲端依賴、功能不及 NX、長期訂閱成本 \n \n \n \n \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w7', 'text': 'w7 ( 2a 採 Youtube 影片簡報 ): \xa0 5-bar Linkage Plotter \xa0 與 \xa0 Openduck mini \xa0零組件設計繪製完成之後，如何切割零件? 為何要切割零件？ 如何利用 \xa0 Webots \xa0 進行後續的控制系統設計與動態模擬 (Dynamic Simulation)？( plotter_project.7z ) \n \n \n \n 蘋果描邊 \n """draw_apple_supervisor controller."""\n\nfrom controller import Supervisor\nimport cv2\nimport numpy as np\nimport math\n\n# ----------------- 固定參數 (米) -----------------\nL1, L2, L3, L4, L5 = 0.20, 0.27, 0.27, 0.20, 0.20\nEx = L5  # E 點的 x 座標 (0.2)\n\n# 目標圓心與半徑\ntarget_center = np.array([0.1, 0.3])\ntarget_radius = 0.1\nN_POINTS = 50\n\n# ----------------- 反解函式 -----------------\ndef ik(cx: float, cy: float) -> tuple:\n    L_AC_sq = cx**2 + cy**2\n    L_AC = math.sqrt(L_AC_sq)\n    if L_AC > (L1 + L2) or L_AC < abs(L1 - L2) or L_AC == 0:\n        return (None, None)\n    alpha = math.atan2(cy, cx)\n    cos_beta1 = (L1**2 + L_AC_sq - L2**2) / (2 * L1 * L_AC)\n    cos_beta1 = np.clip(cos_beta1, -1.0, 1.0)\n    beta1 = math.acos(cos_beta1)\n    sigma1 = 1\n    t1 = alpha + sigma1 * beta1\n\n    dx, dy = cx - Ex, cy\n    L_EC_sq = dx**2 + dy**2\n    L_EC = math.sqrt(L_EC_sq)\n    if L_EC > (L4 + L3) or L_EC < abs(L4 - L3) or L_EC == 0:\n        return (None, None)\n    gamma = math.atan2(dy, dx)\n    cos_beta2 = (L4**2 + L_EC_sq - L3**2) / (2 * L4 * L_EC)\n    cos_beta2 = np.clip(cos_beta2, -1.0, 1.0)\n    beta2 = math.acos(cos_beta2)\n    sigma2 = -1\n    t2 = gamma + sigma2 * beta2\n\n    t1_rad = t1 % (2 * math.pi)\n    t2_rad = t2 % (2 * math.pi)\n    return math.degrees(t1_rad), math.degrees(t2_rad)\n\n# ----------------- 蘋果輪廓處理 -----------------\ndef load_apple_points(image_path, N_points=100):\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    if img is None:\n        print(f"Error: 無法讀取圖片 {image_path}")\n        exit(1)\n    _, binary = cv2.threshold(img, 200, 255, cv2.THRESH_BINARY_INV)\n    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n    if not contours:\n        print("Error: 找不到輪廓")\n        exit(1)\n    main_contour = max(contours, key=cv2.contourArea)\n    if len(main_contour) > N_points:\n        indices = np.linspace(0, len(main_contour) - 1, N_points, dtype=int)\n        sampled = main_contour[indices]\n    else:\n        sampled = main_contour\n    pts = sampled[:, 0, :]\n    h, w = binary.shape\n    pts[:, 1] = h - pts[:, 1]\n    center = np.mean(pts, axis=0)\n    pts_centered = pts - center\n    scale = np.max(np.linalg.norm(pts_centered, axis=1))\n    pts_normalized = pts_centered / scale\n    pts_scaled = pts_normalized * target_radius + target_center\n    return pts_scaled\n\n# ----------------- IndexedLineSet 字串生成 -----------------\ndef generate_indexed_line_set(points):\n    point_str = ",\\n      ".join([f"{x:.5f} {y:.5f} 0.001" for x, y in points])\n    indices = ", ".join([str(i) for i in range(len(points))]) + ", 0"  # 形成封閉線條\n    node_str = f"""\nDEF APPLE_SHAPE Shape {{\n  appearance Appearance {{\n    material Material {{\n      diffuseColor 1 0 0\n      emissiveColor 1 0 0\n    }}\n  }}\n  geometry IndexedLineSet {{\n    coord Coordinate {{\n      point [\n        {point_str}\n      ]\n    }}\n    coordIndex [\n      {indices}\n    ]\n  }}\n}}\n"""\n    return node_str\n\n# ----------------- 主流程 -----------------\ndef main():\n    robot = Supervisor()\n    timestep = int(robot.getBasicTimeStep())\n\n    # 載入輪廓點\n    apple_points = load_apple_points("apple-clip-art.jpg", N_points=N_POINTS)\n\n    # 建立 IndexedLineSet 串接綠線\n    root = robot.getRoot()\n    children_field = root.getField("children")\n    line_node = generate_indexed_line_set(apple_points)\n    children_field.importMFNodeFromString(-1, line_node)\n\n    # 取得馬達\n    t1 = robot.getDevice("t1")\n    t2 = robot.getDevice("t2")\n    t1.setVelocity(5.0)\n    t2.setVelocity(5.0)\n    deg = math.pi / 180\n    t1_offset = -90\n    t2_offset = -17.9\n\n    # 畫圖：依序移動到每個輪廓點\n    for (x, y) in apple_points:\n        t1_deg, t2_deg = ik(x, y)\n        if t1_deg is None or t2_deg is None:\n            print(f"點 ({x:.3f}, {y:.3f}) 超出可達範圍，略過")\n            continue\n        t1_rad = (t1_deg + t1_offset) * deg\n        t2_rad = (t2_deg + t2_offset) * deg\n        t1.setPosition(t1_rad)\n        t2.setPosition(t2_rad)\n\n        # 簡單延遲讓 plotter 有時間移動\n        for _ in range(5):\n            if robot.step(timestep) == -1:\n                return\n        print(f"描點: ({x:.3f}, {y:.3f})")\n\nif __name__ == "__main__":\n    main() \n', 'tags': '', 'url': 'w7.html'}]};